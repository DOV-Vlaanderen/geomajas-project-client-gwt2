<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ This is part of Geomajas, a GIS framework, http://www.geomajas.org/.
  ~
  ~ Copyright 2008-2014 Geosparc nv, http://www.geosparc.com/, Belgium.
  ~
  ~ The program is available in open source according to the GNU Affero
  ~ General Public License. All contributions in this program are covered
  ~ by the Geomajas Contributors License Agreement. For full licensing
  ~ details, see LICENSE.txt in the project root.
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="ch-arch">
  <title>Architecture</title>

  <section>
    <title>The central Map API</title>

    <para>This section describes the interfaces of the most central object
    definitions within the API: those that make up the map model. We start by
    introducing the Geomajas starting point, which is used to create a new map
    instance. From there on, we delve deeper into the most important map
    concepts, such as the layer model and viewport.</para>

    <section>
      <title>Getting started</title>

      <para>As mentioned in the "Configuration" chapter, this client provides
      2 libraries:</para>

      <itemizedlist>
        <listitem>
          <para>The central map API and implementation</para>
        </listitem>

        <listitem>
          <para>Extended functionalities that make use of the Geomajas server
          project</para>
        </listitem>
      </itemizedlist>

      <para>Both have a specific starting point and both starting points
      provide important services, or ways to create a new map. The basic
      Geomajas starting point is:</para>

      <programlisting>org.geomajas.gwt2.client.GeomajasImpl</programlisting>

      <para>When also using the server extension, another starting point
      becomes available:</para>

      <programlisting>org.geomajas.gwt2.client.GeomajasServerExtension</programlisting>

      <para>In the next paragraph we will use this class to create a new
      map.</para>
    </section>

    <section>
      <title>The Geomajas map aka the MapPresenter</title>

      <section>
        <title>MapPresenter responsibilities</title>

        <para>The <code>MapPresenter</code> represents the central map
        interface and as such it determines the map's functionalities. It
        provides support for many of the topics that are discussed in the
        following sections, such as MapControllers or an EventBus.</para>

        <para>In short, the <code>MapPresenter</code> has the following
        responsibilities:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Managing the view on the map</emphasis>: This is
            done through the ViewPort definition.</para>
          </listitem>

          <listitem>
            <para><emphasis>Managing the layers</emphasis>: This is done
            through the LayersModel definition.</para>
          </listitem>

          <listitem>
            <para><emphasis>Providing user interaction</emphasis>: Catching
            native HTML events is done through <code>MapController</code>s.
            The map has support for one active <code>MapController</code> for
            user interaction, and a set of passive map controllers that are
            allowed to catch native events, but may not interrupt default
            event bubbling.</para>
          </listitem>

          <listitem>
            <para><emphasis>Event handling</emphasis>: The MapPresenter
            provides an EventBus through which all specific Geomajas events
            pass. You you can react to changes on the ViewPort, or layer
            composition changes, or, ... A full list of events is provided in
            a later section. The events covered here are Geomajas custom
            events, not native browser events.</para>
          </listitem>

          <listitem>
            <para><emphasis>Rendering and custom drawing</emphasis>: Next to
            the automatic rendering of the layers, the MapPresenter also
            provides API for custom rendering. Custom rendering can occur
            through HTML, VML, SVG and Canvas.</para>
          </listitem>
        </itemizedlist>

        <para>On top of those responsibilities, a map also has a
        configuration, a container for widgets, options for custom drawing,
        etc.</para>

        <para>Before we delve deeper into the map API, let us first show you
        how to create a new map.</para>
      </section>

      <section>
        <title>Creating a new map</title>

        <para>When creating a new map, it is important you provide it with a
        configuration. Now this configuration can be provided through code, or
        it can be provided by the Geomajas server project. Let us start with
        the first option. First of all, you will need to assemble a
        <code>MapConfiguration</code> object, as such:</para>

        <programlisting>MapConfiguration configuration = new MapConfigurationImpl();
configuration.setCrs("EPSG:4326", CrsType.DEGREES);
configuration.setMaxBounds(new Bbox(-180, -90, 360, 180));
configuration.setMinimumResolution(2.682209014892578E-6);</programlisting>

        <para>This is your most basic map configuration object. Although it is
        recommended to provide a list of resolutions, it is not strictly
        required if you make sure to provide a maximum resolution.</para>

        <tip>
          <para>You must provide a zooming range with the map configuration.
          The recommended option is to provided a list of resolutions. The
          alternative is to provided a minimum resolution (=maximum zoom in).
          If you provide the minimum resolution, the map will automatically
          assume the zooming range to be between the maximum resolution set
          out by the maximum bounds and the provided minimum
          resolution.</para>
        </tip>

        <para>Another important factor to note is that we do not simply
        provide a coordinate reference system (crs), we also say how large
        it's units are. This is needed for accurate resolution calculations.
        Currently there are 2 types of CRS supported automatically:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>CrsType.DEGREES</emphasis>: The CRS is expressed
            in degrees. An example is LatLon.</para>
          </listitem>

          <listitem>
            <para><emphasis>CrsType.METRIC</emphasis>: The CRS is expressed in
            meters. An example is Mercator.</para>
          </listitem>
        </itemizedlist>

        <para>It the CRS you want to use is neither, then there is the option
        of manually providing the length of a single unit in meters:</para>

        <programlisting>configuration.setCrs("MyOwnCRS", 1000);</programlisting>

        <para>This would tell the map that a single unit of the CRS is a
        thousand meters in length.</para>

        <para>Now that we have our map configuration, it is time to create a
        new map:</para>

        <programlisting>MapPresenter mapPresenter = GeomajasImpl.getInstance().createMapPresenter(configuration, 480, 480);</programlisting>

        <para>This will create a new map of 480 by 480 pixels in size.</para>
      </section>

      <section>
        <title>Creating a new map using the Geomajas server</title>

        <para>The Geomajas server also knows the concept of maps. Using the
        server project, it is possible to configure as many maps and layers as
        you want in XML, using Spring beans. How to configure these maps is a
        part of the Geomajas server project documentation and outside of the
        scope for this document.</para>

        <para>The client can very easily make use of the map configurations
        provided by the server:</para>

        <programlisting>MapPresenter mapPresenter = GeomajasImpl.getInstance().createMapPresenter();
mapPresenter.setSize(480, 480);
GeomajasServerExtension.getInstance().initializeMap(mapPresenter, "gwt-app", "mapEmpty");</programlisting>

        <para>This example create a new map without a configuration. It this
        point, the map is useless. We than apply a size and fetch a
        configuration from the server. Fetching a configuration, requires you
        to know the name of the map (and it's containing "application"). Those
        are the IDs of the Spring beans in question.</para>
      </section>
    </section>

    <section>
      <title>Map initialization</title>

      <para>When creating a map it might take a while before it's
      configuration is applied (in case you fetch it from the server). As a
      result Geomajas has introduced a <code>MapInitializationEvent</code>.
      This event is fired when the map has been initialized. When providing a
      configuration at the moment you create the map, this event is fired
      immediately. But if you initialize a map with a server-side
      configuration, it takes a while.</para>

      <para>It must also be noted that use a server configuration object may
      automatically inject layers into your map, as this may be part of the
      server-side configuration. Actually, this will most likely be the
      case.</para>

      <para>So if you want to play around with server-side layers or you want
      to change the view on the map, it's best to wait for the
      <code>MapInitializationEvent</code>:</para>

      <programlisting>mapPresenter.getEventBus().addMapInitializationHandler(new MapInitializationHandler() {

    public void onMapInitialized(MapInitializationEvent event) {
        // Do something interesting ...
    }
});</programlisting>
    </section>

    <section>
      <title>Adding the map to the GWT layout</title>

      <para>In order for the map to display correctly, it must have a size.
      You either set a fixed size, like we showed in the previous section, or
      you let some parent widget determine the size. In any case, the map must
      know how large it should be in pixels.</para>

      <para>To this end Geomajas provides a widget to incorporate the map into
      the GWT 2.0 layout system, call the MapLayout:</para>

      <programlisting>org.geomajas.gwt2.client.widget.MapLayoutPanel mapLayout = new MapLayoutPanel(mapPresenter);</programlisting>

      <para>Now add this mapLayout widget to any GWT layout panel, to get the
      map to fill up the available area.</para>
    </section>

    <section>
      <title>Map configuration &amp; hints</title>

      <para>We briefly touched the map configuration when we were trying to
      create a new map. What we did not mention is that this configuration
      object is host to a system of <code>Hint</code>s that provide all kinds
      of settings for the map. These hints can change the default behaviour of
      the map in a lot of different ways. Most hints are defined within the
      <code>MapConfiguration</code> itself.</para>

      <para>The <code>MapConfiguration</code> can be retrieved as such:</para>

      <programlisting>org.geomajas.gwt2.client.map.MapConfiguration mapConfiguration = mapPresenter.getConfiguration();</programlisting>

      <para>With this configuration it is possible to apply and retrieve
      <code>Hints</code> concerning the map. All <code>Hints</code> are
      defined to only accept a certain type of value through Java's generic
      types:</para>

      <programlisting>mapConfiguration.setHintValue(Hint&lt;T&gt; hint, T value);</programlisting>

      <para>By default the following MapHints are defined:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>MapConfiguration.ANIMATION_TIME</emphasis>: Hint
          used to determine how long the animations should take during
          navigation (zooming). The value should be expressed in
          milliseconds.</para>
        </listitem>

        <listitem>
          <para><emphasis>MapConfiguration.FADE_IN_TIME</emphasis>: Hint used
          to determine how long fading in of resolution or tiles should take
          while rendering the map.</para>
        </listitem>

        <listitem>
          <para><emphasis>MapConfiguration.ANIMATION_CANCEL_SUPPORT</emphasis>:
          Hint that determines whether or not the ViewPort will cancel the
          currently running animation in favor of a new animation. If this
          value is false, the new animation will keep running, and the new
          animation is discarded. If this value is true, the current animation
          is discontinued, and the new one is started.</para>
        </listitem>

        <listitem>
          <para><emphasis>MapConfiguration.DPI</emphasis>: Hint used to
          determine the DPI on the map.</para>
        </listitem>

        <listitem>
          <para>.....</para>
        </listitem>
      </itemizedlist>

      <para>This is an example of how one would change the default animation
      time to last 1 second:</para>

      <programlisting>mapConfiguration.setMapHintValue(MapConfiguration.ANIMATION_TIME, 1000);</programlisting>
    </section>

    <section>
      <title>Managing the view on the map</title>

      <section>
        <title>The ViewPort</title>

        <para>One of the most important concepts within a map is it's position
        and how to navigate from one place to another. Most of the time it
        will be the user that determines navigation through a controller on
        the map (mouse or touch). Sometimes though it might be necessary to
        have the map navigate to some pre-defined location through
        code.</para>

        <para>The whole navigation and positioning concept is bundled within
        the ViewPort. The ViewPort can be accessed directly from the
        MapPresenter:</para>

        <programlisting>org.geomajas.gwt2.client.map.ViewPort viewPort = mapPresenter.getViewPort();</programlisting>

        <para>Through the ViewPort one can get the current map
        position:</para>

        <programlisting>org.geomajas.gwt2.client.map.View view = viewPort.getView();
org.geomajas.geometry.Coordinate position = viewPort.getPosition();
org.geomajas.geometry.Bbox bounds = viewPort.getBounds();
double resolution = viewPort.getResolution();</programlisting>

        <para>Next to acquiring current location, you can also force the map
        to navigate to a certain location instantly:</para>

        <programlisting>viewPort.applyPosition(new Coordinate(0,0));
viewPort.applyResolution(0.01);
viewPort.applyBounds(new Bbox(0,0,100,100));</programlisting>
      </section>

      <section>
        <title>Navigating using animations</title>

        <para>These days a map must be able to navigate using fluid
        animations. This too is a part of the Geomajas API in the form of
        the:</para>

        <programlisting>org.geomajas.gwt2.client.animation.NavigationAnimation</programlisting>

        <para>For the most basic animation types (zooming, panning, ...)
        Geomajas provides a factory:</para>

        <programlisting>org.geomajas.gwt2.client.animation.NavigationAnimationFactory</programlisting>

        <para>Using this factory it is possible to create your own animations.
        Once created though, you still have to register them with the
        ViewPort.</para>

        <para>The following example creates a new zoom in animation and
        applies it immediately:</para>

        <programlisting>NavigationAnimation animation = NavigationAnimationFactory.createZoomIn(mapPresenter);
mapPresenter.getViewPort().registerAnimation(animation);</programlisting>
      </section>

      <section>
        <title>Rendering spaces</title>

        <para>The <code>ViewPort</code> can be seen as the navigator behind
        the map. It manages the map's navigation (by making it zoom or pan)
        and sends the required events. On top of that, the
        <code>ViewPort</code> also has a second responsibility in providing
        transformations between different rendering spaces.</para>

        <para>Visit the <link linkend="world_vs_screen">WorldSpace vs
        ScreenSpace</link> section for more information.</para>
      </section>
    </section>

    <section>
      <title>Layer composition</title>

      <para>Also part of the central map model, is a separate interface for
      managing all the layers of the map. As is typically the case in GIS,
      people work not just with one type of data, but with many different
      types that are all represented by "layers" in a map. These layers always
      have a certain order in which they are drawn, as they lie on top of each
      other.</para>

      <para>The LayersModel is directly accessible from the
      MapPresenter:</para>

      <programlisting>org.geomajas.gwt2.client.map.layer.LayersModel layersModel = mapPresenter.getLayersModel();</programlisting>

      <para>This model has the following responsibilities:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Adding and removing layers</emphasis>: These methods
          will add layers on top, or remove existing layers from the
          map.</para>
        </listitem>

        <listitem>
          <para><emphasis>Retrieving layers</emphasis>: You can retrieve layer
          objects through their unique ID, or by index. It's also possible to
          get the total layer count.</para>
        </listitem>

        <listitem>
          <para><emphasis>Moving layers up and down</emphasis>: Remember that
          the layers form an ordered list, so these methods will change the
          layer order.</para>
        </listitem>

        <listitem>
          <para><emphasis>Get the currently selected layer</emphasis>: The
          layer API provides the possibility to select one single layer. This
          option can be used for specific use-cases revolving around a single
          layer.</para>
        </listitem>
      </itemizedlist>

      <para>Note that almost all changes in the LayersModel will trigger
      specific events, making it easy to follow up on changes.</para>
    </section>

    <section>
      <title>Layer API</title>

      <para>As many different types of layers exist all with their own
      specific set of functionalities, we have decided to reflect this
      diversity in the layer interface, by splitting it up in multiple
      'functional' interfaces. There is still a main
      <code>org.geomajas.gwt2.client.map.layer.Layer</code> interface, which
      must always be implemented, but layer implementations can decide for
      themselves which of the 'functional' interfaces they support and which
      they don't.</para>

      <section>
        <title>Supporting interfaces</title>

        <para>On top of the basic layer interface, the following extensions
        are available:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.map.layer.FeaturesSupported</emphasis>:
            Extension for layers that contain features. Features are the base
            vector-objects a layers can consist of.</para>
          </listitem>

          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.map.layer.LabelsSupported</emphasis>:
            Allows labels for a layer to be turned on or off.</para>
          </listitem>

          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.map.layer.LegendUrlSupported</emphasis>:
            Extension that can provide URLs to the legend images for this
            layer. A WMS layer for example will implement this to point to the
            GetLegendGraphic URL.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Server-side layer integration</title>

        <para>As was just mentioned, multiple interfaces exist that make up a
        layers functionality. The server-extension provides additional layer
        types that make use of layers that have been defined on the server.
        There are 2 types:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.map.layer.VectorServerLayer</emphasis>:
            A proxy to any vector layer type that has been defined on the
            server. These can in turn be WFS, Database, Shapefile, ....</para>
          </listitem>

          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.map.layer.RasterServerLayer</emphasis>:
            A proxy to any raster layer type that has been defined on the
            server. These can in turn be WMS, TMS, Google maps, ...</para>
          </listitem>
        </itemizedlist>

        <para>These types of layer are defined on the server. They are usually
        added to a map configuration on the server as well. When you create a
        new map using such a server map configuration, these layers will
        already be present in the client-side map object.</para>
      </section>

      <section>
        <title>Attributes, descriptors and features</title>

        <para>In the previous section we briefly mentioned the Feature
        (<code>org.geomajas.gwt2.client.map.feature.Feature</code>) concept.
        Features are the individual objects that make up vector layers (layers
        that implement
        <code>org.geomajas.gwt2.client.map.layer.FeaturesSupported</code>).</para>

        <para>A Feature itself contains the following information:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>A unique ID</emphasis>: Every feature should have
            a unique identifier within it's layer.</para>
          </listitem>

          <listitem>
            <para><emphasis>A map of attributes</emphasis>: A layer usually
            has a fixed set of attributes configured. For each such attribute,
            the feature may have a value in it's attribute map.</para>
          </listitem>

          <listitem>
            <para><emphasis>A geometry</emphasis>: Without a geometry, the
            feature can not be displayed on a map...</para>
          </listitem>
        </itemizedlist>

        <para>Features have an attribute mapping. For every attribute defined
        within a layer, the feature has a value. The list of attribute you can
        expect to find in features, are provided by the FeaturesSupported
        interface:</para>

        <programlisting>List&lt;AttributeDescriptor&gt; descriptors = featuresSupportedLayer.getAttributeDescriptors();</programlisting>

        <para>Every attribute descriptor has a name and a type. Using the
        name, one can find the values on features:</para>

        <programlisting>Object attributeValue = feature.getAttributeValue(attributeDescriptor.getName());</programlisting>

        <para>Many types of attributes exist. As a result, the AttributeType
        has multiple extensions and implementations. At this time, 2 types are
        supported:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>PrimitiveAttributeType</emphasis>: An attribute
            whose value holds a primitive Java type, such as Strings,
            Integers, Double, Dates, ...</para>
          </listitem>

          <listitem>
            <para><emphasis>GeometryAttributeType</emphasis>: An attribute
            type that holds a Geometry as value.</para>
          </listitem>
        </itemizedlist>

        <remark>The Geomajas server project has support for more complex types
        of attributes such as many-to-one and one-to-many attributes. Expect
        these to be supported as well in the future in the Geomajas client
        2.x</remark>

        <section>
          <title>Feature Selection</title>

          <para>The FeaturesSupported interface allows for feature
          selection:</para>

          <programlisting>FeaturesSupported fs = (FeaturesSupported) layer;
fs.selectFeature(feature);
boolean selected = fs.isFeatureSelected(feature); // returns true
fs.clearSelectedFeatures(); // Deselect all features within this layer.
selected = fs.isFeatureSelected(feature); // returns false</programlisting>
        </section>
      </section>
    </section>
  </section>

  <section>
    <title>Events</title>

    <section>
      <title id="geomajas_vs_native_events">Geomajas events versus native
      events</title>

      <para>When developing GWT or Javascript applications, it is important to
      be aware of the difference between HTML native events and custom created
      events.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Native events</emphasis>: Events that are triggered
          by the browser. They are typically triggered by input devices such
          as the mouse, the keyboard or touch screens. These events are
          provided in Geomajas through the <code>MapController</code>, which
          lets you define user interaction on the map. These are not the topic
          of this section. For more information on native browser events,
          visit the <link linkend="user_interaction">User Interaction</link>
          section.</para>
        </listitem>

        <listitem>
          <para><emphasis>Custom events</emphasis>: These are used for
          Geomajas specific events, such as the MapInitializationEvent we have
          covered earlier. You can catch these events through the Geomajas
          <code>MapEventBus</code>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>EventBus concept</title>

      <para>Associated with the functionalities in the central map interfaces,
      are several events that signal changes in the model to all registered
      handlers. Note that the term <code>Handler</code> is used, not listener,
      as we try to follow the GWT naming conventions. As of GWT 2.x, the use
      of a central eventbus has been promoted to work together with an MVP
      approach.</para>

      <para>Instead of randomly providing methods to register handlers for
      specific events, Geomajas follows the GWT reasoning in that it's much
      easier to work with a central event service: The EventBus. The idea is
      that all events are passed through this bus, so that the developer never
      needs to figure out where to register the handlers. Also, the EventBus
      can be a singleton service available everywhere in your code.</para>

      <para>The Geomajas setup goes a bit further though in that it provides
      an EventBus for every map plus an application specific EventBus. The
      application specific event bus is optional, but can be an easy way to
      add your own events.</para>

      <section>
        <title>Geomajas MapEventBus</title>

        <para>We start out be explaining the map centric event bus. For every
        map you create, there is one such event bus. This eventbus will
        provide all Geomajas specific events originating from within the map.
        It is not meant to be extended by adding new event types. Note that if
        you create multiple maps, you will also have multiple such event
        busses.</para>

        <para>The next piece of code shows you how to get access to it:</para>

        <programlisting>org.geomajas.gwt2.client.map.MapEventBus mapEventBus = mapPresenter.getEventBus();</programlisting>

        <para>This means that for <code>Handlers</code> that are registered on
        such an eventbus, only events that have originated within that map
        will reach it. Here is an example of how one can attach a Handler to
        an EventBus:</para>

        <programlisting>mapPresenter.getEventBus().addHandler(MapResizedEvent.TYPE, new MapResizedHandler() {

    public void onMapResized(MapResizedEvent event) {
        // The map has resized. Quick, do something meaningful!
    }
});</programlisting>

        <para>In the example above a <code>MapResizedHandler</code> was used
        that listens to <code>MapResizedEvents</code>. From the moment the
        <code>MapResizedHandler</code> has been registered, it will receive
        all events that indicate the map has been resized. This handler will
        not receive <code>MapResizedEvents</code> from other maps, only from
        this one.</para>

        <para>This bus only provides Geomajas specific events. For a list, see
        <link linkend="event_overview">event overview</link>.</para>
      </section>

      <section>
        <title>Application EventBus</title>

        <para>Next to the map specific event bus, Geomajas also provides an
        eventbus singleton through the <code>GeomajasImpl</code>:</para>

        <programlisting>com.google.web.bindery.event.shared.EventBus eventBus = GeomajasImpl.getInstance().getEventBus();</programlisting>

        <para>This is a default GWT EventBus that is not actually used by
        Geomajas to provides map specific events, but is here as a singleton
        for application designers to add application specific events
        to.</para>
      </section>
    </section>

    <section>
      <title id="event_overview">Event overview</title>

      <para>Time to go over all supported events and explain their purpose.
      Note that every event in this list is part of the GWT client API within
      Geomajas. All event and handler classes can be found in the following
      package: <code>org.geomajas.gwt.client.map.event</code>.</para>

      <para><emphasis role="bold">Map events:</emphasis></para>

      <table>
        <title>Map Events</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Event</entry>

              <entry align="center">Handler</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>MapInitializationEvent</entry>

              <entry>MapInitializationHandler</entry>

              <entry>Event that is fired when the map has been initialized.
              Only after this point will layers be available.</entry>
            </row>

            <row>
              <entry>MapResizedEvent</entry>

              <entry>MapResizedHandler</entry>

              <entry>Event that is fired when the map widget has changed
              size.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><emphasis role="bold">ViewPort events:</emphasis><table>
          <title>ViewPort Events</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Event</entry>

                <entry align="center">Handler</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>ViewPortChangedEvent</entry>

                <entry>ViewPortChangedHandler</entry>

                <entry>Event that is fired when the view on the ViewPort has
                been changed.</entry>
              </row>

              <row>
                <entry>NavigationStartEvent</entry>

                <entry>NavigationStartHandler</entry>

                <entry>Event that is fired when the ViewPort starts an
                animated navigation sequence.</entry>
              </row>

              <row>
                <entry>NavigationUpdateEvent</entry>

                <entry>NavigationUpdateHandler</entry>

                <entry>Event that is fired when the ViewPort reports an update
                in the navigation animation.</entry>
              </row>

              <row>
                <entry>NavigationStopEvent</entry>

                <entry>NavigationStopHandler</entry>

                <entry>Event that is fired when an animated navigation
                sequence in the ViewPort has just ended</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para><emphasis role="bold">Layer events:</emphasis><table>
          <title>Layer Events</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Event</entry>

                <entry align="center">Handler</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>LayerAddedEvent</entry>

                <entry>MapCompositionHandler</entry>

                <entry>Event that is fired when a new layer has been added to
                the map.</entry>
              </row>

              <row>
                <entry>LayerRemovedEvent</entry>

                <entry>MapCompositionHandler</entry>

                <entry>Event that is fired when a layer has been removed from
                the map.</entry>
              </row>

              <row>
                <entry>LayerSelectedEvent</entry>

                <entry>LayerSelectionHandler</entry>

                <entry>Event that is fired when a layer is selected. Only one
                layer can be selected at any time, so these events often go
                together with layer deselect events.</entry>
              </row>

              <row>
                <entry>LayerDeselectedEvent</entry>

                <entry>LayerSelectionHandler</entry>

                <entry>Event that is fired when a layer has been deselected.
                Only one layer can be selected at any one time.</entry>
              </row>

              <row>
                <entry>LayerHideEvent</entry>

                <entry>LayerVisibilityHandler</entry>

                <entry>Event that is fired when a layer disappears from view.
                This can be caused because some layer are only visible between
                certain resolution levels, or because the user turned a layer
                off. This event is often triggered by a
                <code>LayerVisibilityMarkedEvent</code>.</entry>
              </row>

              <row>
                <entry>LayerShowEvent</entry>

                <entry>LayerVisibilityHandler</entry>

                <entry>Event that is fired when a layer becomes visible. This
                can be caused because some layer are only visible between
                certain resolution levels, or because the user turned a layer
                on. This event is often triggered by a
                <code>LayerVisibilityMarkedEvent</code>.</entry>
              </row>

              <row>
                <entry>LayerLabelHideEvent</entry>

                <entry>LayerLabeledHandler</entry>

                <entry>Event that is fired when the labels of a layer have
                become invisible.</entry>
              </row>

              <row>
                <entry>LayerLabelShowEvent</entry>

                <entry>LayerLabeledHandler</entry>

                <entry>Event that is fired when the labels of a layer have
                become visible.</entry>
              </row>

              <row>
                <entry>LayerLabelMarkedEvent</entry>

                <entry>LayerLabeledHandler</entry>

                <entry>Event that is fired when the labels of a layer have
                been marked as visible or invisible. Note that when labels
                have been marked as invisible at a moment when they where
                actually visible, than you can expect a
                <code>LayerLabelHideEvent</code> shortly. On the other hand
                marking labels as visible does not necessarily mean that they
                will become visible. For labels to becomes visible, they must
                be invisible and their layer must be visible as well. Only if
                those requirements are met will the labels truly become
                visible and can you expect a <code>LayerLabelShowEvent</code>
                to follow this event.</entry>
              </row>

              <row>
                <entry>LayerOrderChangedEvent</entry>

                <entry>LayerOrderChangedHandler</entry>

                <entry>Event that is fired when the order of a layer is
                changed within the <code>LayersModel</code>. This event
                contains indices pointing to the original index and the target
                index for the layer. Of course, changing the index of a single
                layer, also changes the indices of other layers.</entry>
              </row>

              <row>
                <entry>LayerRefreshedEvent</entry>

                <entry>LayerRefreshedHandler</entry>

                <entry>Event that reports a layer has been refreshed. This
                means it's rendering is completely cleared and
                redrawn.</entry>
              </row>

              <row>
                <entry>LayerStyleChangedEvent</entry>

                <entry>LayerStyleChangedHandler</entry>

                <entry>Event that reports changes in layer style.</entry>
              </row>

              <row>
                <entry>LayerVisibilityMarkedEvent</entry>

                <entry>LayerVisibilityHandler</entry>

                <entry>Called when a layer has been marked as visible or
                invisible. When a layer has been marked as invisible, expect a
                <code>LayerHideEvent</code> very soon. But, when a layer has
                been marked as visible, that does not necessarily mean it will
                become visible. There are more requirements that have to be
                met in order for a layer to become visible: the map's
                resolution must be between the minimum and maximum allowed
                resolutions for the layer. If that requirement has been met as
                well, expect a <code>LayerShowEvent</code> shortly.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para><emphasis role="bold">Feature events:</emphasis><table>
          <title>Feature Events</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Event</entry>

                <entry align="center">Handler</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>FeatureSelectedEvent</entry>

                <entry>FeatureSelectionHandler</entry>

                <entry>Event that is fired when a feature has been
                selected.</entry>
              </row>

              <row>
                <entry>FeatureDeselectedEvent</entry>

                <entry>FeatureSelectionHandler</entry>

                <entry>Event that is fired when a selected feature has been
                deselected again.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para><emphasis role="bold">Other events:</emphasis><table>
          <title>Other Events</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Event</entry>

                <entry align="center">Handler</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>TileLevelRenderedEvent</entry>

                <entry>TileLevelRenderedHandler</entry>

                <entry>Event that is fired when a resolution level has been
                rendered. This is used by resolution-based layer renderers,
                and it is up to them to determine when that is.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>
  </section>

  <section>
    <title id="user_interaction">User interaction</title>

    <para>This section will handle the basics of interacting with the map, by
    listening and responding to native browser events (mouse, touch, keyboard)
    generated from the map. The notion of native events versus custom Geomajas
    events was mentioned earlier in the "<link
    linkend="geomajas_vs_native_events">Events</link>" section.</para>

    <section>
      <title>MapController definition</title>

      <para>The basic definition for map interaction is called the
      MapController, which is the combination of a set of mouse and touch
      handlers, with some added utility methods. At least the following
      handlers must be implemented:</para>

      <itemizedlist>
        <listitem>
          <para>MouseDownHandler</para>
        </listitem>

        <listitem>
          <para>MouseUpHandler</para>
        </listitem>

        <listitem>
          <para>MouseMoveHandler</para>
        </listitem>

        <listitem>
          <para>MouseOutHandler</para>
        </listitem>

        <listitem>
          <para>MouseOverHandler</para>
        </listitem>

        <listitem>
          <para>MouseWheelHandler</para>
        </listitem>

        <listitem>
          <para>DoubleClickHandler</para>
        </listitem>

        <listitem>
          <para>TouchStartHandler</para>
        </listitem>

        <listitem>
          <para>TouchEndHandler</para>
        </listitem>

        <listitem>
          <para>TouchMoveHandler</para>
        </listitem>

        <listitem>
          <para>TouchCancelHandler</para>
        </listitem>

        <listitem>
          <para>GestureStartHandler</para>
        </listitem>

        <listitem>
          <para>GestureEndHandler</para>
        </listitem>

        <listitem>
          <para>GestureChangeHandler</para>
        </listitem>
      </itemizedlist>

      <para>On top of handling mouse and touch events, the MapController
      definition also provides methods that are executed when a MapController
      becomes active on the map, or when it is deactivated.</para>
    </section>

    <section>
      <title>Applying your own MapController on the map</title>

      <para>The MapController definition can be used in 2 different ways: as a
      manipulative event controller, or as a passive listener. The main
      difference is that the listener is not allowed to manipulate the events,
      while the controller is free to do as it chooses. A controller could for
      example stop event propagation, something a listener is not allowed to
      do. As a result only one controller is allowed on the map, while
      multiple listeners are allowed.</para>

      <para>We have used the terms 'controller' and 'listener', but in reality
      both are defined by the same interface:
      <code>org.geomajas.gwt2.client.controller.MapController</code>. It's a
      difference in semantics.</para>

      <para>The following code sample shows how to apply both on the
      map:</para>

      <programlisting>// Applying a new MapController on the map:
mapPresenter.setMapController(new MyCustomController());

// Adding an additional listener:
mapPresenter.addMapListener(new MyCustomController());</programlisting>

      <para>A typical example of an active controller is the
      NavigationController, which determines map navigation through mouse
      handling.</para>

      <para>A typical example of a passive listener could be a widget that
      reads in the location of the mouse on the map, and prints out the X,Y
      coordinates. Such a MapController implementation does not interfere with
      the normal event flow or the main MapController.</para>

      <para>By default, a NavigationController is active on the map. Should
      you apply another MapController, you will loose your default navigation
      abilities (unless you implement them in your MapController as well). At
      any time you can reinstall the default NavigationController like
      this:</para>

      <programlisting>mapPresenter.setMapController(null);</programlisting>

      <tip>
        <para>When writing your own MapControllers it is recommended to always
        start from the <code>AbstractMapController</code>, or even from the
        <code>NavigationController</code>.</para>
      </tip>
    </section>

    <section>
      <title>Working with events on the map</title>

      <para>Often, MapControllers need to interpret the events in some way to
      determine their course of action. Let us take an example where a
      MapController wants to read the mouse position on the map in order to
      print it out on the GUI. In order to do this, you will need to know the
      mouse position at the time of each MouseMoveEvent on the map.</para>

      <para>For this case, the MapController also extends the
      <code>org.geomajas.gwt2.client.controller.MapEventParser</code>
      interface. This interface provides methods for extracting useful
      information from events:</para>

      <programlisting>// Get the event location in map CRS:
Coordinate worldPosition = mapController.getLocation(event, RenderSpace.WORLD);</programlisting>

      <para>This method extracts the location of the event, expressed in one
      of the rendering spaces (more in this later).</para>

      <programlisting>// Get the DOM elements that was the target of the event:
Element target = mapController.getTarget(event);</programlisting>

      <para>This method extracts the target DOM element of the event.</para>
    </section>
  </section>

  <section>
    <title id="graphics_rendering">Graphics &amp; Rendering</title>

    <para>This section will handle all rendering related topics, explaining
    the different render spaces (WorldSpace versus ScreenSpace), and how to
    make full advantage of them when trying to render objects on the
    map.</para>

    <section>
      <title id="world_vs_screen">WorldSpace vs ScreenSpace</title>

      <para>Before trying to render anything on a map, it is crucial you
      understand the difference between WorldSpace and ScreenSpace. Both
      represent render spaces wherein the user can render his objects.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>WorldSpace</emphasis>: World space describes a
          rendering space where all objects are expressed in the coordinate
          reference system of the map. As a result, all objects within world
          space move about with the view on the map.</para>

          <para>Let's say for example that a rectangle is rendered on a map
          with CRS lon-lat. The rectangle has origin (118,34) and width and
          height both equal to 1. Than this rectangle will cover the city of
          Los Angeles. No matter where the user may navigate, the rectangle
          will always remain above Los Angeles.</para>
        </listitem>

        <listitem>
          <para><emphasis>ScreenSpace</emphasis>: Screen space describes a
          rendering space where all objects are expressed in pixels with the
          origin in the top left corner of the map. Objects rendered in screen
          will always occupy a fixed position on the map. They are immobile
          and are not affected by map navigation.</para>
        </listitem>
      </itemizedlist>

      <caution>
        <para>Beware that drawing a great many objects in WorldSpace can slow
        down an application, as their positions need to be recalculated every
        time the map navigates.</para>
      </caution>
    </section>

    <section>
      <title>Rendering containers</title>

      <para>Before actually rendering custom objects on the map, you must
      choose a type of container wherein to draw. This type of container will
      determine the the format used in HTML:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>org.geomajas.gwt2.client.gfx.VectorContainer</emphasis>:
          Depending on the browser used, this container will render in either
          SVG or VML.</para>
        </listitem>

        <listitem>
          <para><emphasis>org.geomajas.gwt2.client.gfx.CanvasContainer</emphasis>:
          This container will make use of the HTML5 canvas construct for
          drawing.</para>
        </listitem>

        <listitem>
          <para><emphasis>org.geomajas.gwt2.client.gfx.TransformableWidgetContainer</emphasis>:
          A container that is meant to display widget in WorldSpace on the
          map. For example, this could be used to render image markers on
          certain locations.</para>
        </listitem>
      </itemizedlist>

      <para>These containers are meant for custom rendering. They have nothing
      to do with the layer of the map. Containers will always be rendered
      separately and on top of all the layers. All containers are managed by
      the <code>ContainerManager</code>, which can be acquired through the
      <code>MapPresenter</code>:</para>

      <programlisting>org.geomajas.gwt2.client.map.ContainerManager containerManager = mapPresenter.getContainerManager();</programlisting>

      <section>
        <title>VectorContainers &amp; VectorObjects</title>

        <para>For vector object rendering, the GWT client makes use of the
        Vaadin GwtGraphics library. This library provides all the necessary
        methods for standard SVG and VML rendering. The main interfaces to
        note are the <code>VectorContainer</code> and the
        <code>VectorObject</code>.</para>

        <para>The VectorContainer is a container object as the name implies
        and provides methods for storing and managing VectorObjects. These
        VectorObjects in turn are the individual objects (such as Rectangle,
        Circle, Path, ...) that can be drawn on the map.</para>

        <para>In order to acquire a VectorContainer, all one has to do is
        request such a container from the MapPresenter. This can be done by
        calling one of the following methods:</para>

        <programlisting>// Getting a VectorContainer for rendering in WorldSpace:
VectorContainer worldContainer = mapPresenter.getContainerManager().addWorldContainer();

// Getting a VectorContainer for rendering in ScreenSpace:
VectorContainer screenContainer = mapPresenter.getContainerManager().addScreenContainer();</programlisting>

        <para>After acquiring such a container it is possible to add multiple
        VectorObjects to it.</para>

        <note>
          <para>Be careful to make sure you use the correct coordinate system
          when adding VectorObjects to your VectorContainer. A container that
          was added in ScreenSpace, expects it's VectorObjects to be expressed
          in pixel coordinates (integer values). A container that was added in
          WorldSpace expexts it's VectorObjects to be expressed in world
          coordinates or user coordinates (the more general term used in
          GwtGraphics).</para>
        </note>
      </section>

      <section>
        <title>CanvasContainers</title>

        <para>There is some experimental support for HTML5 canvas rendering.
        To create a new the canvas container, call the following
        method:</para>

        <programlisting>CanvasContainer canvasContainer = mapPresenter.getContainerManager().addWorldCanvas();</programlisting>

        <para>The canvas rendering API is entirely different from the SVG/VML
        rendering APIs. Canvas is not DOM-based, but provides a generic 2D
        context and pen for stroking and filling primitives like paths, arcs
        and rectangles, drawing text and images, etc... This will sound
        familiar to those of you that have used the java Graphics2D API.
        Canvas provides full control of the pixel-by-pixel appearance of the
        image that you are drawing. The down-side of canvas is that the
        responsibility of redrawing the image whenever the state changes (and
        this means any state change, including simple panning or zooming) is
        left to the application. Canvas also lacks the concept of objects or
        event targeting, it is just a dumb image. This can of course be
        mitigated by keeping track of rendered objects yourself (after all,
        this is what most drawing software using Graphics2D does), but this is
        much more complicated than with a DOM-based model.</para>

        <para>Our simple container implementation keeps track of a list of
        CanvasShape objects and will automatically repaint them whenever the
        map is translated or scaled. The container will react immediately when
        shapes are added or removed, although the repaint method can be called
        explicitly as well (e.g. when an object is updated) :<programlisting>public interface CanvasContainer extends Transformable, Transparent, IsWidget {
  void addShape(CanvasShape shape);
  void addAll(List&lt;CanvasShape&gt; shapes);
  void removeShape(CanvasShape shape);
  void clear();
  void repaint();
  void setPixelSize(int width, int height);
}</programlisting></para>

        <para>The shape objects themselves have to implement a paint() method
        to draw themselves on the canvas (in world coordinates). An example of
        such a drawing method for a simple rectangle (CanvasRect) is shown
        here:</para>

        <programlisting>  @Override
  public void paint(Canvas canvas, Matrix matrix) {
    canvas.getContext2d().save();
    canvas.getContext2d().setFillStyle(fillStyle);
    canvas.getContext2d().fillRect(box.getX(), box.getY(), box.getWidth(), box.getHeight());
    canvas.getContext2d().setStrokeStyle(strokeStyle);
    canvas.getContext2d().setLineWidth(strokeWidthPixels / matrix.getXx());
    canvas.getContext2d().strokeRect(box.getX(), box.getY(), box.getWidth(), box.getHeight());
    canvas.getContext2d().restore();
  }</programlisting>

        <para>Notice that the previous context state is saved at the start and
        restored at the end. This ensures that we don't propagate context
        changes between successive shapes. The body of the code is simply
        drawing a rectangle in the required fill and stroke style. We have to
        divide the original line width in pixels by the resolution factor
        (assuming uniform scaling) because it will be multiplied afterwards by
        the container as part of the world-to-screen transformation.</para>

        <para>The container implementation uses a simple form of double
        buffering to make it fast and can render hunderds of thousands of
        rectangles at once with an acceptable performance. There is presently
        no support for handling events on a per-shape basis, though, so this
        is mostly useful for background rendering.</para>
      </section>
    </section>

    <section>
      <title>Drawing geometries on the map</title>

      <para>Often one needs to draw geometries on the map. Say we have a
      Feature who's geometry we want to render in a specific style. Since a
      Feature is a part of a <code>FeaturesSupported</code> layer, it's
      geometry is expressed in the map CRS. Hence we will want to render it's
      geometry in WorldSpace. So we start by creating a
      <code>VectorContainer</code>:</para>

      <programlisting>// Getting a VectorContainer for rendering in WorldSpace:
VectorContainer worldContainer = mapPresenter.getContainerManager().addWorldContainer();</programlisting>

      <para>Next we want to add the geometry as a Path to the
      <code>VectorContainer</code>. First we need to transform the geometry
      into a VectorObject:</para>

      <programlisting>// Transform the geometry into a VectorObject that can be rendered in a container:
VectorObject vectorObject = GeomajasImpl.getInstance().getGfxUtil().toShape(feature.getGeometry());</programlisting>

      <para>Before adding the path to the <code>VectorContainer</code>, we may
      want to style it first:</para>

      <programlisting>GeomajasImpl.getInstance().getGfxUtil().applyFill(vectorObject, "#0066AA", 0.5);
GeomajasImpl.getInstance().getGfxUtil().applyStroke(vectorObject, "#004499", 0.9, 2, null);</programlisting>

      <para>Now it's time to add the path to the
      <code>VectorContainer</code>:</para>

      <programlisting>VectorContainer worldContainer = mapPresenter.getContainerManager().addWorldContainer();
worldContainer.add(vectorObject);</programlisting>
    </section>
  </section>

  <section>
    <title>Client/Server communication</title>

    <para>This part of the documentation handles the communication with the
    Geomajas server project. Use of the Geomajas server project is optional
    but recommended.</para>

    <para>Although this chapter of the documentation is about the Gwt client
    API, Geomajas is at it's heart a client/server based framework. The client
    needs the server to operate correctly. The client/server communication
    mechanism used is a command pattern based upon the GWT RPC
    services.</para>

    <para>An example of this communication is the map that fetches it's
    configuration from the server when it initializes.</para>

    <section>
      <title>CommandService</title>

      <para>Most client/server communication that Geomajas does is through a
      command pattern based upon the GWT RPC services. The Geomajas server
      knows many Commands, which are defined as Spring beans. This
      communication mechanism is used to fetch server-side map configurations
      or for rendering server-layers.</para>

      <para>The commands available are always defined on the server, but can
      be called from the client. Most commands are used internally by
      Geomajas, but often, backend plugins provide additional commands for the
      client to use. For this, the
      <code>org.geomajas.gwt2.client.service.CommandService</code> singleton
      is provided. This service can be accessed as follows:</para>

      <programlisting>CommandService commandService = GeomajasServerExtension.getInstance().getCommandService();</programlisting>

      <para>Next you can use this service to execute a command:</para>

      <programlisting>// Prepare a command:
EmptyCommandRequest request = new EmptyCommandRequest();
GwtCommand command = new GwtCommand();
command.setCommandName("command.GetSimpleExceptionCommand"); // Maybe not the best example...
command.setCommandRequest(request);

// Now execute the command:
commandService.execute(command, new AbstractCommandCallback&lt;CommandResponse&gt;() {

    @Override
    public void execute(CommandResponse response) {
        // don't do anything. An Exception will been thrown at server-side
    }
});</programlisting>

      <para>This example is taken from the showcase, where a command is
      created that throws an exception. Perhaps not the most useful command,
      but it's a clear example.</para>

      <para>Every command is defined by a request and a response object. We
      create a client-side GwtCommand object that refers to the backend
      command implementation through a string identifier, in this case
      "command.GetSimpleExceptionCommand". Normally this string is defined as
      a public static string in the request object.</para>
    </section>

    <section>
      <title>Custom client/server communication</title>

      <para>Although Geomajas uses a command pattern for it's own
      client/server communication, it is not limited by it. After all,
      Geomajas uses the GWT framework which has native support for Ajax calls
      (Json, XML, ...). When creating your own WebServices, you are not bound
      to extend Geomajas' commands. It is perfectly possible to write your own
      RESTful service or a custom GWT RPC service instead.</para>
    </section>
  </section>

  <section>
    <title>Widgets/controls</title>

    <section>
      <title>The default map control widgets</title>

      <section>
        <title>Overview of the default map controls</title>

        <para>By default Geomajas will add a few control widgets to the map.
        These provide general navigation functionalities to the user. If you
        are not satisfied, you can always replace the defaults with
        others.</para>

        <para>The following is a list of widgets that are available out of the
        box:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.widget.control.scalebar.Scalebar</emphasis>:
            The scalebar shown in the bottom left of the map.</para>

            <screenshot>
              <screeninfo>Scalebar</screeninfo>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
                             fileref="images/controls/Scalebar.png" />
                </imageobject>
              </mediaobject>
            </screenshot>
          </listitem>

          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.widget.control.zoom.ZoomControl</emphasis>:
            The default zoom control widget, showing a zoom in and a zoom out
            button.</para>

            <screenshot>
              <screeninfo>ZoomControl</screeninfo>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
                             fileref="images/controls/ZoomControl.png" />
                </imageobject>
              </mediaobject>
            </screenshot>
          </listitem>

          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.widget.control.zoomtorect.ZoomToRectangleControl</emphasis>:
            Button that allows the user to zoom in to a rectangle. The user
            needs to drag the rectangle after clicking this button.</para>

            <screenshot>
              <screeninfo>ZoomToRectangleControl</screeninfo>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
                             fileref="images/controls/ZoomToRectangleControl.png" />
                </imageobject>
              </mediaobject>
            </screenshot>
          </listitem>

          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.widget.control.pan.PanControl</emphasis>:
            A widget that provides 4 buttons to pan the map in 4 directions
            (north, east, south, west).</para>

            <screenshot>
              <screeninfo>PanControl</screeninfo>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
                             fileref="images/controls/PanControl.png" />
                </imageobject>
              </mediaobject>
            </screenshot>
          </listitem>

          <listitem>
            <para><emphasis>org.geomajas.gwt2.client.widget.control.zoom.ZoomStepControl</emphasis>:
            A widget that provides a zoom step for every resolution available
            in the map configuration. This way a user can zoom directly to a
            certain zoom level should he choose to.</para>

            <screenshot>
              <screeninfo>ZoomStepControl</screeninfo>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
                             fileref="images/controls/ZoomStepControl.png" />
                </imageobject>
              </mediaobject>
            </screenshot>
          </listitem>
        </itemizedlist>

        <para>By default a Geomajas map will contain the following widgets:
        <code>ScaleBar</code>, <code>ZoomControl</code>,
        <code>ZoomToRectangleControl</code>.</para>
      </section>

      <section>
        <title>Using alternative map controls</title>

        <para>Let's say you want to create a new map, and make use of the
        PanControl and ZoomStepControl instead of the default ZoomControl. For
        this reason, Geomajas has defined the:</para>

        <programlisting>org.geomajas.gwt2.client.widget.DefaultMapWidget</programlisting>

        <para>It is an enumeration that lists the map widgets Geomajas
        provides by default (the list in the previous section basically). It
        is possible to use this enumeration to list the types of widget you
        want on the map at startup. The following piece of code shows you how
        to do just that:</para>

        <programlisting>GeomajasServerExtension.getInstance().initializeMap(mapPresenter, "gwt-app", "mapOsm",
        new DefaultMapWidget[] { DefaultMapWidget.ZOOM_TO_RECTANGLE_CONTROL, DefaultMapWidget.PAN_CONTROL,
                DefaultMapWidget.ZOOM_STEP_CONTROL, DefaultMapWidget.SCALEBAR });</programlisting>

        <para>This piece of code would result in a map that looks like
        this:</para>

        <screenshot>
          <screeninfo>Alternative controls</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="images/controls/alternativecontrols.png" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </section>
    </section>

    <section>
      <title>Adding widgets on top of the map</title>

      <para>As you know, Geomajas will add a few widgets to the map by
      default. Let's say you want to use your own widgets, or you want the
      default widgets to appear at a different location. Know that any widget
      that Geomajas adds to the map, is still available through the maps
      widget pane. This is a panel onto which one can add any widget. This
      panel can be retrieved as such:</para>

      <programlisting>HasWidgets panel = mapPresenter.getWidgetPane();</programlisting>

      <para>The panel is by default implemented through an AbsolutePanel. This
      is a GWT layout panel wherein all widgets are positioned absolutely
      (actually using the CSS position:absolute construct). So when adding
      widget to it, make sure you set their position to absolute, and give
      them top, left, bottom or right values (CSS).</para>

      <para>So let us go through an example wherein we want to add the
      PanControl separately, and add it to the upper right corner of the
      map:</para>

      <programlisting>mapPresenter.getEventBus().addMapInitializationHandler(new MapInitializationHandler() {

    public void onMapInitialized(MapInitializationEvent event) {
        // Create the PanControl:
        PanControl panControl = new PanControl(mapPresenter);

        // Make the PanControl stick to the upper-right corner, 5 pixels from the border:
        panControl.getElement().getStyle().clearLeft(); // Just to be sure...
        panControl.getElement().getStyle().setTop(5, Unit.PX);
        panControl.getElement().getStyle().setRight(5, Unit.PX);

        // Now add the PanControl to the map:
        mapPresenter.getWidgetPane().add(panControl);
    }
});</programlisting>

      <para>Note we have waited for the MapInitializationEvent to add widgets
      to the map. This is not strictly necessary, but safer. Perhaps some of
      the widgets you use may need the map to be fully initialized.</para>
    </section>
  </section>
</chapter>
